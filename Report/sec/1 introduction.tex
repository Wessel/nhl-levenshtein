\section{Introduction}
\label{sec:introduction}
This report will focus on understanding functional programming
languages and their differences compared to imperative languages.
The implementation of the Levenshtein ratio algorithm is discribed in three
different programming styles and compares the results on multiple fronts.

The Levenshtein ratio algorithm is a commonly used
algorithm to measure the similarity between two strings.
It is applied in various fields such as spell checking and plagiarism detection.
By implementing this algorithm in different programming languages,
the performance and code complexity can be compared to understand the differences that
exist between multiple programming paradigms.

The following languages were chosen for this comparison, each representing a different paradigm:
\begin{itemize}
  \item[-] \makebox[3.2cm]{\textbf{Haskell (Functional)}\hfill} A purely functional language that
  emphasizes immutability and recursion. Known for its concise and expressive code.
  \item[-] \makebox[3.2cm]{\textbf{Csharp  (Imperative)}\hfill} An object-oriented language mainly
  used to develop Windows applications and games.
  \item[-] \makebox[3.2cm]{\textbf{TypeScript (Semi)}\hfill} A language that supports both
  imperative and functional constructs. Known for its leniant interperter.
\end{itemize}

The comparison will be based on the following criteria:
\begin{enumerate}
  \item[I.] \makebox[2.4cm]{\textbf{Performance}\hfill} time complexity and resource usage of the algorithm.
  \item[II.] \makebox[2.4cm]{\textbf{Readability}\hfill} how simple and intuitive the code is.
  \item[II.] \makebox[2.4cm]{\textbf{Maintainability}\hfill} is the code easy to maintain and future-proof.
\end{enumerate}
